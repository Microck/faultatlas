---
phase: 02-analysis-pipeline
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/trace.py
  - src/models/findings.py
  - src/analyzers/__init__.py
  - src/analyzers/trace_analyzer.py
  - tests/fixtures/traces/booking.json
  - tests/fixtures/traces/search.json
  - tests/fixtures/traces/summary.json
  - tests/test_trace_analyzer.py
autonomous: true
must_haves:
  truths:
    - "Trace Analyzer identifies the failure step (N of M) for each subject trace"
    - "Trace Analyzer extracts a structured reasoning chain"
  artifacts:
    - path: "src/analyzers/trace_analyzer.py"
      provides: "Trace parsing + failure step identification"
    - path: "src/models/findings.py"
      provides: "Pydantic models for analyzer output"
    - path: "tests/test_trace_analyzer.py"
      provides: "Unit coverage for core trace parsing"
  key_links:
    - from: "tests/fixtures/traces/*.json"
      to: "src/analyzers/trace_analyzer.py"
      via: "fixture-driven tests"
      pattern: "fixtures/traces"

---

<objective>
Build the Trace Analyzer and the canonical trace/findings data models.

Purpose: Turn stored traces into analysis-ready, structured findings.
Output: Trace models, Findings models, TraceAnalyzer, and unit tests with fixtures.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define canonical Trace + Findings models</name>
  <files>
src/models/trace.py
src/models/findings.py
  </files>
  <action>
- Add `src/models/trace.py` describing the stored trace shape Phase 1 produced (steps, tool_calls, errors, timestamps).
- Add `src/models/findings.py` with:
  - `TraceFinding` containing `failure_step`, `total_steps`, `failure_location`, `error`, and `reasoning_chain` (list of strings).
  - `ToolFinding` placeholder model (fields can be optional for now) so IndagineController can unify results later.
  - `FindingsReport` model that can hold multiple analyzer findings by analyzer name.
- Keep models compatible with JSON serialization (no complex types).
  </action>
  <verify>
python3 -c "from src.models.findings import FindingsReport; print(FindingsReport.model_json_schema().get('title'))"
  </verify>
  <done>
- Models exist and can be serialized/deserialized from JSON
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TraceAnalyzer with fixture-driven tests</name>
  <files>
src/analyzers/__init__.py
src/analyzers/trace_analyzer.py
tests/fixtures/traces/booking.json
tests/fixtures/traces/search.json
tests/fixtures/traces/summary.json
tests/test_trace_analyzer.py
  </files>
  <action>
- Implement `src/analyzers/trace_analyzer.py` with `analyze(trace_record) -> TraceFinding`.
- Heuristics (keep deterministic):
  - Failure step = first step with `error` present or validation_error marker.
  - Total steps = len(steps).
  - Reasoning chain = list of `thought`/`decision` fields if present; otherwise derive from tool_calls + inputs.
- Add fixtures in `tests/fixtures/traces/*.json` representing the expected structure from Phase 1 for each subject.
- Add `tests/test_trace_analyzer.py` asserting:
  - Correct `failure_step` and `total_steps` for each fixture.
  - Reasoning chain contains key phrases (e.g. date string for booking).
  </action>
  <verify>
python3 -m pytest -q
  </verify>
  <done>
- TraceAnalyzer passes tests for all three fixture traces
  </done>
</task>

</tasks>

<verification>
- `python3 -m pytest -q` passes
</verification>

<success_criteria>
- TraceAnalyzer returns stable, structured results suitable for diagnosis (Phase 3)
</success_criteria>

<output>
After completion, create `.planning/phases/02-analysis-pipeline/02-01-SUMMARY.md`
</output>
