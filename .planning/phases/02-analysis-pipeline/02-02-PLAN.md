---
phase: 02-analysis-pipeline
plan: "02"
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/tools/registry.py
  - src/tools/schema_registry.py
  - src/analyzers/tool_analyzer.py
  - tests/fixtures/traces/tool_calls_search.json
  - tests/test_tool_analyzer.py
autonomous: true
must_haves:
  truths:
    - "Tool Analyzer validates tool call arguments against JSON schemas"
    - "Tool Analyzer detects wrong-tool selection in the SearchAgent scenario"
  artifacts:
    - path: "src/analyzers/tool_analyzer.py"
      provides: "Tool schema validation + wrong-tool detection"
    - path: "src/tools/schema_registry.py"
      provides: "Central schema lookup used by analyzers"
  key_links:
    - from: "src/analyzers/tool_analyzer.py"
      to: "src/tools/schema_registry.py"
      via: "schema loading"
      pattern: "SchemaRegistry"

---

<objective>
Build the Tool Analyzer that detects invalid tool parameters and wrong tool selection.

Purpose: Make TOOL_MISUSE diagnosable from traces, not guesswork.
Output: ToolAnalyzer + schema registry + unit tests.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-analysis-pipeline/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SchemaRegistry shared by subjects + analyzers</name>
  <files>
src/tools/registry.py
src/tools/schema_registry.py
  </files>
  <action>
- Create `src/tools/schema_registry.py` as the single source of truth for tool schema lookup.
- Create `src/tools/schema_registry.py` as the single source of truth for tool schema lookup.
- Load schemas from `src/tools/schemas/*.json` and expose `list_tools()`, `get_schema(tool_name)`, and `validate(tool_name, args)`.
- Keep it compatible with both:
  - subject scenario validation (Phase 1)
  - ToolAnalyzer validation (this plan)
If Phase 1 already created `src/tools/registry.py`, refactor by moving shared logic into `schema_registry.py` and keeping `registry.py` as a thin wrapper (do not change public behavior).
  </action>
  <verify>
python3 -c "from src.tools.schema_registry import SchemaRegistry; print(sorted(SchemaRegistry().list_tools()))"
  </verify>
  <done>
- SchemaRegistry loads schemas, lists available tools, and validates tool args
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ToolAnalyzer + tests using tool-call fixtures</name>
  <files>
src/analyzers/tool_analyzer.py
tests/fixtures/traces/tool_calls_search.json
tests/test_tool_analyzer.py
  </files>
  <action>
- Implement `src/analyzers/tool_analyzer.py` with `analyze(trace_record) -> ToolFinding`.
- Required behavior:
  - For each tool call in the trace, validate args via SchemaRegistry and record mismatches.
  - Detect wrong-tool selection by comparing `intended_tool` (if present in trace metadata) vs `tool_name` used.
  - If `intended_tool` not present, infer wrong tool for SearchAgent fixture via a simple rule: if the user asks to "search" and the agent calls `summarize_sources` first, flag it.
- Add `tests/fixtures/traces/tool_calls_search.json` that isolates tool call records for SearchAgent.
- Add `tests/test_tool_analyzer.py` asserting:
  - At least one schema mismatch is detected
  - Wrong-tool selection is flagged for the SearchAgent fixture
  </action>
  <verify>
python3 -m pytest -q
  </verify>
  <done>
- ToolAnalyzer returns stable findings and tests pass
  </done>
</task>

</tasks>

<verification>
- `python3 -m pytest -q` passes
</verification>

<success_criteria>
- TOOL_MISUSE can be detected purely from trace content
</success_criteria>

<output>
After completion, create `.planning/phases/02-analysis-pipeline/02-02-SUMMARY.md`
</output>
