---
phase: 01-foundation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - requirements.txt
  - .env.example
  - infra/foundry_config.yaml
  - src/core/foundry_client.py
  - src/core/tracing.py
  - src/scripts/verify_foundry.py
  - tests/test_smoke.py
autonomous: true
user_setup:
  - service: azure-ai-foundry
    why: "Run agents with Foundry tracing enabled"
    env_vars:
      - name: FOUNDRY_PROJECT_ENDPOINT
        source: "Azure AI Foundry portal -> Project settings -> Endpoint"
      - name: FOUNDRY_MODEL_DEPLOYMENT
        source: "Azure AI Foundry portal -> Models -> Deployments"
    auth:
      - method: "DefaultAzureCredential"
        how: "Run `az login` locally OR set AZURE_CLIENT_ID/AZURE_TENANT_ID/AZURE_CLIENT_SECRET"
must_haves:
  truths:
    - "Repo has a runnable Python project skeleton"
    - "Foundry client config is centralized and loaded from env"
    - "Tracing bootstrap can be enabled without changing subject agent code"
  artifacts:
    - path: "pyproject.toml"
      provides: "Python tooling (pytest, ruff) configuration"
    - path: "infra/foundry_config.yaml"
      provides: "Single place for Foundry-related configuration defaults"
    - path: "src/core/foundry_client.py"
      provides: "Factory to create an authenticated Foundry project client"
    - path: "src/core/tracing.py"
      provides: "Tracing bootstrap for agent runs"
  key_links:
    - from: "src/core/foundry_client.py"
      to: ".env / process env"
      via: "FOUNDRY_PROJECT_ENDPOINT + FOUNDRY_MODEL_DEPLOYMENT"
      pattern: "FOUNDRY_PROJECT_ENDPOINT|FOUNDRY_MODEL_DEPLOYMENT"
    - from: "src/scripts/verify_foundry.py"
      to: "src/core/foundry_client.py"
      via: "verify connectivity"
      pattern: "verify_.*foundry|create_.*client"
    - from: "src/scripts/verify_foundry.py"
      to: "src/core/tracing.py"
      via: "configure_tracing()"
      pattern: "configure_tracing"

---

<objective>
Create the minimal Python + Foundry scaffolding so later phases can implement agents, tracing, and storage without re-deciding structure.

Purpose: Reduce integration thrash; make all later code importable and runnable.
Output: Python project skeleton, Foundry config, and tracing bootstrap.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@/home/ubuntu/workspace/ai-dev-days-hackathon/plans/indagine.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Python project skeleton + test tooling</name>
  <files>
pyproject.toml
requirements.txt
tests/test_smoke.py
src/__init__.py
src/core/__init__.py
src/storage/__init__.py
src/subjects/__init__.py
  </files>
  <action>
- Create `pyproject.toml` with a minimal toolchain: pytest (tests), ruff (lint), and a consistent Python version target (3.11+).
- Create `requirements.txt` with only what Phase 1 needs: `azure-ai-projects` (Foundry Agents/Project client), `azure-identity` (DefaultAzureCredential), `pydantic`, `python-dotenv`, `opentelemetry-sdk`, `azure-monitor-opentelemetry`, `azure-cosmos` (Cosmos in later Plan 01-03), `jsonschema` (tool JSON Schema validation), plus `pytest`.
- Add a minimal `tests/test_smoke.py` so `pytest -q` is deterministic (pytest exits non-zero if no tests are collected).
  - Include at least one collected test function (e.g., `def test_smoke_imports(): ...`) so pytest collection is non-empty.
  - Keep it dependency-light: import one local module like `src.core.tracing` and `assert True`.
- Add empty `__init__.py` files so `import src...` works in tests and scripts.
  </action>
  <verify>
 python3 -m pip install -r requirements.txt
 python3 -c "import jsonschema"
 pytest -q
  </verify>
  <done>
- Repo installs cleanly with pip
- `pytest -q` exits 0
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Foundry config + client factory</name>
  <files>
.env.example
infra/foundry_config.yaml
src/core/foundry_client.py
src/scripts/verify_foundry.py
  </files>
  <action>
- Add `.env.example` documenting *only* the env vars this project will read directly.
- Add `infra/foundry_config.yaml` with defaults/placeholders for the project endpoint and model deployment name.
- Implement `src/core/foundry_client.py`:
  - Load config from environment first, fall back to `infra/foundry_config.yaml`.
  - Create Foundry project client using `DefaultAzureCredential`.
  - Avoid embedding any secrets in code or YAML.
- Add `src/scripts/verify_foundry.py` (CLI) that performs an explicit v1 verification path for FOUND-01:
  - Prints the resolved Foundry config (endpoint + deployment name) and fails fast if missing.
  - Creates the Foundry client and performs one lightweight, read-only call that proves the project/deployment is reachable.
    - Use the smallest/cheapest SDK call available (e.g., get project details and/or validate the named deployment exists).
  - Calls `configure_tracing()` and emits a single span so we can confirm the exporter path is configured (console in local fallback; Azure Monitor when configured).
  </action>
  <verify>
python3 -c "from src.core.foundry_client import load_foundry_config; print(load_foundry_config())"
python3 -m src.scripts.verify_foundry
  </verify>
  <done>
- Foundry config loads without exceptions when env vars are present
- Client factory is a single import used by later plans
- `python3 -m src.scripts.verify_foundry` proves the project endpoint + model deployment are reachable (when env/auth configured)
- `python3 -m src.scripts.verify_foundry` emits at least one span (console fallback or Azure Monitor when configured)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tracing bootstrap module</name>
  <files>
src/core/tracing.py
  </files>
  <action>
- Implement `src/core/tracing.py` with a `configure_tracing()` function that:
  - Uses Azure Monitor OpenTelemetry exporter when a connection string is available (from Foundry project telemetry or env).
  - Falls back to a console exporter when no Azure Monitor config is present (so local dev still shows spans).
- Keep the API surface tiny: later code should call `configure_tracing()` once at process start.
- Make the chosen exporter observable:
  - `configure_tracing()` should log/print which exporter path is active (azure-monitor vs console) so `verify_foundry.py` can assert configuration.
  </action>
  <verify>
python3 -c "from src.core.tracing import configure_tracing; configure_tracing(); print('tracing-ok')"
  </verify>
  <done>
- A single call enables tracing (Azure Monitor when configured; console otherwise)
  </done>
</task>

</tasks>

<verification>
- `python3 -m pip install -r requirements.txt` succeeds
- `pytest -q` exits 0
</verification>

<success_criteria>
- Phase 1 can proceed without reworking project structure
- Foundry configuration is centralized and documented via `.env.example`
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
